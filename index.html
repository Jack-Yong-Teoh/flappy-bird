<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Bird Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            overflow: hidden; /* Prevent scrolling */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* Disable default touch actions */
            -webkit-user-select: none;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #70c5ce; /* Sky blue */
            overflow: hidden;
            margin: 0 auto;
            max-width: 600px; /* Limit width on large screens */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s ease-out;
            z-index: 20;
        }

        .score-display {
            position: absolute;
            top: 10%;
            font-size: 60px;
            font-weight: 900;
            color: white;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            z-index: 10;
            font-family: monospace;
        }

        #start-screen, #game-over-screen {
            pointer-events: auto;
            text-align: center;
        }

        /* Styling for the Score Board Card */
        .score-card {
            background-color: #ded895;
            border: 2px solid #543847;
            border-radius: 10px;
            padding: 20px;
            width: 280px;
            margin: 0 auto;
            position: relative;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
            text-align: left;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
        }

        .medal-container {
            width: 60px;
            height: 60px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            border: 2px solid #e86101;
        }

        .score-text-group {
            text-align: right;
        }

        .score-label {
            color: #e86101;
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .score-value {
            font-size: 24px;
            color: white;
            font-weight: 900;
            text-shadow: 2px 2px 0 #000;
            font-family: monospace;
            margin-bottom: 10px;
        }

        h1 {
            color: #f4b642;
            font-size: 50px;
            margin: 0 0 20px 0;
            text-shadow: 4px 4px 0 #000, -2px -2px 0 #000;
            font-weight: 900;
            line-height: 1;
        }

        .btn {
            background-color: #e86101;
            color: white;
            border: 2px solid white;
            padding: 12px 25px;
            font-size: 18px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            margin-top: 20px;
            transition: transform 0.1s;
            box-shadow: 0 4px 0 #b34a00;
            font-family: inherit;
        }

        .btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #b34a00;
        }

        .hidden {
            display: none !important;
        }

        /* Power Up UI */
        .power-bar-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 15;
            pointer-events: none;
        }

        .power-bar {
            width: 150px;
            height: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 5px;
            overflow: hidden;
            display: none;
            position: relative;
            border: 2px solid white;
        }

        .power-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div class="power-bar-container">
        <div id="bar-invincible" class="power-bar">
            <div class="power-fill" style="background-color: #ffd700;"></div>
        </div>
        <div id="bar-shrink" class="power-bar">
            <div class="power-fill" style="background-color: #4287f5;"></div>
        </div>
    </div>

    <div id="flash-overlay"></div>
    <div class="score-display hidden" id="score-hud">0</div>

    <div id="ui-layer">
        <div id="start-screen">
            <h1>FLAPPY<br>BIRD</h1>
            <p style="color:white; font-weight:bold; text-shadow:1px 1px 0 #000;">Collect Stars & Potions!</p>
            <button class="btn" id="start-btn">Start Game</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1 style="font-size: 40px; margin-bottom: 15px;">GAME OVER</h1>
            
            <div class="score-card">
                <div class="medal-container" id="medal-display">
                    <!-- Medal Emoji Inserted via JS -->
                </div>
                <div class="score-text-group">
                    <div class="score-label">Score</div>
                    <div class="score-value" id="final-score">0</div>
                    <div class="score-label">Best</div>
                    <div class="score-value" id="high-score">0</div>
                </div>
            </div>

            <button class="btn" id="restart-btn">Play Again</button>
        </div>
    </div>
</div>

<script>
    // --- Audio System ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();

    const sounds = {
        jump: () => playTone(350, 'square', 0.1, -12, 0),
        score: () => playTone(1200, 'sine', 0.1, -18, 0),
        hit: () => playTone(150, 'sawtooth', 0.05, -5, 0),
        die: () => playTone(100, 'sawtooth', 0.2, -5, 0.1),
        swoosh: () => playTone(600, 'triangle', 0.1, -15, 0),
        powerup: () => playTone(600, 'sine', 0.3, -10, 0, 'slide') // New sound
    };

    function playTone(freq, type, duration, vol, delay, effect) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        const t = audioCtx.currentTime + delay;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, t);
        
        if(effect === 'slide') {
             osc.frequency.exponentialRampToValueAtTime(freq + 600, t + 0.3);
        } else if(type === 'square') {
            osc.frequency.exponentialRampToValueAtTime(freq + 200, t + 0.1);
        }

        gain.gain.setValueAtTime(Math.pow(10, vol/20), t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.start(t);
        osc.stop(t + duration);
    }

    // --- Game Engine ---

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('game-container');
    
    // UI Elements
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const scoreHud = document.getElementById('score-hud');
    const finalScoreEl = document.getElementById('final-score');
    const highScoreEl = document.getElementById('high-score');
    const medalDisplay = document.getElementById('medal-display');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    const flashOverlay = document.getElementById('flash-overlay');
    
    // Power UI
    const barInvincible = document.getElementById('bar-invincible');
    const barShrink = document.getElementById('bar-shrink');

    // Game Constants
    let frames = 0;
    const DEGREE = Math.PI / 180;
    
    // Game State
    const state = {
        current: 0,
        getReady: 0,
        game: 1,
        over: 2
    };

    let scale = 1;
    
    function resize() {
        const rect = container.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        scale = canvas.width / 320; 
        if (scale > 1.4) scale = 1.4;
    }
    
    window.addEventListener('resize', resize);
    resize();

    function inputAction(e) {
        if(e.type === 'keydown' && e.code !== 'Space') return;
        if(e.type === 'keydown') e.preventDefault(); 

        switch (state.current) {
            case state.getReady:
                state.current = state.game;
                scoreHud.classList.remove('hidden');
                startScreen.classList.add('hidden');
                bird.flap();
                sounds.jump();
                break;
            case state.game:
                bird.flap();
                sounds.jump();
                break;
            case state.over:
                break;
        }
    }

    startBtn.addEventListener('click', () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        state.current = state.game;
        scoreHud.classList.remove('hidden');
        startScreen.classList.add('hidden');
        bird.flap();
        sounds.jump();
    });

    restartBtn.addEventListener('click', () => {
        state.current = state.getReady;
        gameOverScreen.classList.add('hidden');
        startScreen.classList.remove('hidden');
        scoreHud.classList.add('hidden');
        
        pipes.reset();
        bird.reset();
        powerUps.reset();
        score.value = 0;
        frames = 0;
        flashOverlay.style.opacity = 0;
        sounds.swoosh();
        
        // Hide power bars
        barInvincible.style.display = 'none';
        barShrink.style.display = 'none';
    });

    window.addEventListener('keydown', inputAction);
    canvas.addEventListener('mousedown', (e) => {
        if(state.current === state.game) inputAction(e);
    });
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); 
        if(state.current === state.game) inputAction(e);
    }, {passive: false});

    // --- Game Objects ---

    const bg = {
        draw: function() {
            ctx.fillStyle = "#70c5ce";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#fff";
            const w = canvas.width;
            ctx.fillStyle = "#a3e5ae";
            const buildingH = 150 * scale;
            ctx.fillRect(0, canvas.height - buildingH, w, buildingH);
            ctx.fillStyle = "#95d6a0";
            for(let i=0; i<w; i+=40*scale) {
                if(i % 80 == 0) ctx.fillRect(i, canvas.height - buildingH, 20*scale, 40*scale);
            }
        }
    }

    const ground = {
        h: 90, 
        draw: function() {
            const h = this.h * scale;
            const y = canvas.height - h;
            
            ctx.fillStyle = "#ded895";
            ctx.fillRect(0, y, canvas.width, h);
            
            const stripeW = 20 * scale;
            let offset = 0;
            if(state.current == state.game || state.current == state.getReady) {
                offset = (frames * (2.5 * scale)) % stripeW;
            }
            
            ctx.fillStyle = "#d0c874";
            for(let i = -1; i < canvas.width / stripeW + 1; i++) {
                ctx.beginPath();
                ctx.moveTo(i * stripeW - offset, y);
                ctx.lineTo((i * stripeW) + (10 * scale) - offset, canvas.height);
                ctx.lineTo((i * stripeW) - (5 * scale) - offset, canvas.height);
                ctx.lineTo((i * stripeW) - (15 * scale) - offset, y);
                ctx.fill();
            }
            
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.lineWidth = 3 * scale;
            ctx.strokeStyle = "#5a9e65";
            ctx.stroke();
        }
    }

    const bird = {
        animation: [0, 1, 2, 1],
        x: 50,
        y: 150,
        speed: 0,
        gravity: 0.18, 
        jump: 3.6,     
        rotation: 0,
        radius: 12,
        frame: 0,
        
        // Power Up State
        powers: {
            invincible: 0, // timer
            shrink: 0      // timer
        },
        
        draw: function() {
            let birdX = this.x * scale;
            let birdY = this.y;
            
            // Handle Shrink Size
            let scaleMult = this.powers.shrink > 0 ? 0.6 : 1.0;
            let size = this.radius * 2.2 * scale * scaleMult; 

            ctx.save();
            ctx.translate(birdX, birdY);

            // Invincible Shield Effect
            if(this.powers.invincible > 0) {
                ctx.beginPath();
                ctx.arc(0, 0, size/1.5 + 5, 0, Math.PI*2);
                ctx.strokeStyle = `rgba(255, 215, 0, ${Math.abs(Math.sin(frames/5)) + 0.5})`;
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Pulse opacity
                if(Math.floor(frames/4) % 2 === 0) ctx.globalAlpha = 0.8;
            }

            ctx.rotate(this.rotation);

            // Body
            ctx.beginPath();
            ctx.arc(0, 0, size/2, 0, Math.PI*2);
            ctx.fillStyle = "#f4b642";
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#000";
            ctx.stroke();

            // Eye
            ctx.beginPath();
            ctx.arc(size/4, -size/4, size/4.5, 0, Math.PI*2);
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.stroke();
            
            // Pupil
            ctx.beginPath();
            ctx.arc(size/3.5, -size/4, size/12, 0, Math.PI*2);
            ctx.fillStyle = "#000";
            ctx.fill();

            // Wing
            ctx.beginPath();
            const wingY = (this.animation[this.frame] === 1) ? 0 : (this.animation[this.frame] === 0 ? -3 : 3);
            ctx.ellipse(-size/10, size/10 + wingY, size/2.5, size/3.5, -0.2, 0, Math.PI*2);
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.stroke();

            // Beak
            ctx.beginPath();
            ctx.arc(size/3, size/8, size/5, 0, Math.PI*2);
            ctx.fillStyle = "#e86101";
            ctx.fill();
            ctx.stroke();

            ctx.restore();
            
            // Update UI Bars
            this.updateUI();
        },
        
        updateUI: function() {
            if (this.powers.invincible > 0) {
                barInvincible.style.display = 'block';
                barInvincible.querySelector('div').style.width = (this.powers.invincible / 300 * 100) + '%';
            } else {
                barInvincible.style.display = 'none';
            }
            
            if (this.powers.shrink > 0) {
                barShrink.style.display = 'block';
                barShrink.querySelector('div').style.width = (this.powers.shrink / 480 * 100) + '%';
            } else {
                barShrink.style.display = 'none';
            }
        },
        
        flap: function() {
            let jumpForce = this.jump;
            // Slightly smaller jump if shrunk to keep control tight
            if(this.powers.shrink > 0) jumpForce *= 0.85; 
            
            this.speed = -jumpForce * scale;
            this.rotation = -25 * DEGREE;
        },
        
        update: function() {
            // Decrement Power Timers
            if (this.powers.invincible > 0) this.powers.invincible--;
            if (this.powers.shrink > 0) this.powers.shrink--;

            const period = state.current == state.getReady ? 10 : 5;
            this.frame += frames % period == 0 ? 1 : 0;
            this.frame = this.frame % this.animation.length;

            if (state.current == state.getReady) {
                this.y = (canvas.height / 2) - 50 * scale;
                this.y += Math.cos(frames/15) * 4 * scale;
                this.x = canvas.width / 2 - (15 * scale);
                this.rotation = 0;
            } else {
                this.x = canvas.width / 3;
                this.speed += this.gravity * scale;
                this.y += this.speed;

                if(this.speed < this.jump/2 * scale) {
                    this.rotation = -25 * DEGREE;
                } else {
                    this.rotation += 2 * DEGREE;
                    this.rotation = Math.min(this.rotation, 90 * DEGREE);
                }

                if (this.y + this.radius * scale >= canvas.height - (ground.h * scale)) {
                    this.y = canvas.height - (ground.h * scale) - this.radius * scale;
                    this.die();
                }
                
                if (this.y < 0) {
                    this.y = 0;
                    this.speed = 0;
                }
            }
        },
        
        die: function() {
            if (state.current == state.game) {
                state.current = state.over;
                sounds.hit();
                setTimeout(sounds.die, 300);
                flashScreen();
                showGameOver();
            }
        },

        reset: function() {
            this.speed = 0;
            this.rotation = 0;
            this.y = 150;
            this.powers.invincible = 0;
            this.powers.shrink = 0;
        }
    }
    
    // --- Power Up System ---
    const powerUps = {
        items: [], // {x, y, type} 0=Star, 1=Potion
        
        draw: function() {
            for(let i=0; i<this.items.length; i++) {
                let p = this.items[i];
                let px = p.x;
                let py = p.y;
                let sz = 20 * scale;
                
                ctx.save();
                ctx.translate(px + sz/2, py + sz/2);
                // Float animation
                ctx.translate(0, Math.sin(frames/10) * 5); 
                
                if(p.type === 0) { // Star
                    // Draw Star
                    ctx.beginPath();
                    for(let j=0; j<5; j++) {
                        ctx.lineTo(Math.cos((18 + j*72)*DEGREE)*sz, -Math.sin((18+j*72)*DEGREE)*sz);
                        ctx.lineTo(Math.cos((54 + j*72)*DEGREE)*sz/2, -Math.sin((54+j*72)*DEGREE)*sz/2);
                    }
                    ctx.closePath();
                    ctx.fillStyle = "#ffd700";
                    ctx.fill();
                    ctx.strokeStyle = "#d4af37";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else { // Potion
                    // Draw Potion
                    ctx.fillStyle = "#4287f5";
                    ctx.beginPath();
                    ctx.arc(0, 0, sz/1.5, 0, Math.PI*2);
                    ctx.fill();
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    // Shine
                    ctx.fillStyle = "rgba(255,255,255,0.6)";
                    ctx.beginPath();
                    ctx.arc(-sz/4, -sz/4, sz/4, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }
        },
        
        update: function() {
             if (state.current !== state.game) return;
             
             // Spawn logic: Random chance when frames align, but simpler to bind to pipes?
             // Let's spawn randomly in between pipes
             if(frames % 300 === 150) { // Offset from pipe spawn
                 if(Math.random() > 0.3) { // 70% chance to spawn powerup
                     const type = Math.random() > 0.5 ? 0 : 1;
                     // Spawn in playable area
                     const groundY = canvas.height - (ground.h * scale);
                     const y = Math.random() * (groundY - 100) + 50;
                     
                     this.items.push({
                         x: canvas.width,
                         y: y,
                         type: type,
                         active: true
                     });
                 }
             }
             
             for(let i=0; i<this.items.length; i++) {
                 let p = this.items[i];
                 p.x -= pipes.dx * scale; // Move with world
                 
                 // Collision with Bird
                 let birdSz = bird.radius * 2 * scale;
                 let pSz = 30 * scale; 
                 // Simple rect collision
                 if (bird.x < p.x + pSz && bird.x + birdSz > p.x &&
                     bird.y < p.y + pSz && bird.y + birdSz > p.y) {
                     
                     // Collect
                     sounds.powerup();
                     if(p.type === 0) {
                         bird.powers.invincible = 300; // 5 seconds (60fps)
                     } else {
                         bird.powers.shrink = 480; // 8 seconds
                     }
                     
                     this.items.splice(i, 1);
                     i--;
                     continue;
                 }
                 
                 if(p.x < -50) {
                     this.items.splice(i, 1);
                     i--;
                 }
             }
        },
        
        reset: function() {
            this.items = [];
        }
    }

    const pipes = {
        position: [],
        w: 52,
        dx: 2.0,       
        gap: 125,      
        
        draw: function() {
            for (let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                let topY = p.y;
                let bottomY = p.y + this.gap * scale;
                let pX = p.x;
                let pW = this.w * scale;
                
                const pipeColor = "#73bf2e";
                const pipeBorder = "#558c22";

                // Top Pipe
                ctx.fillStyle = pipeColor;
                ctx.fillRect(pX, 0, pW, topY);
                ctx.strokeStyle = pipeBorder; 
                ctx.lineWidth = 2;
                ctx.strokeRect(pX, -2, pW, topY + 2); 
                
                ctx.fillRect(pX - 3, topY - 20 * scale, pW + 6, 20 * scale);
                ctx.strokeRect(pX - 3, topY - 20 * scale, pW + 6, 20 * scale);

                // Bottom Pipe
                ctx.fillStyle = pipeColor;
                ctx.fillRect(pX, bottomY, pW, canvas.height - bottomY - (ground.h * scale)); 
                ctx.strokeRect(pX, bottomY, pW, canvas.height - bottomY - (ground.h * scale));

                ctx.fillRect(pX - 3, bottomY, pW + 6, 20 * scale);
                ctx.strokeRect(pX - 3, bottomY, pW + 6, 20 * scale);
            }
        },
        
        update: function() {
            if (state.current !== state.game) return;

            if (frames % 110 == 0) {
                const groundY = canvas.height - (ground.h * scale);
                const gapSize = this.gap * scale;
                
                const minPipe = 30 * scale;
                const maxPipe = groundY - minPipe - gapSize;

                const posY = Math.random() * (maxPipe - minPipe) + minPipe;

                this.position.push({
                    x: canvas.width,
                    y: posY,
                    passed: false
                });
            }

            for (let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                p.x -= this.dx * scale;

                // Adjust Hitbox for Powerups
                let effectiveRadius = bird.radius;
                if (bird.powers.shrink > 0) effectiveRadius *= 0.6; // Smaller hitbox if shrunk
                
                const birdRad = (effectiveRadius - 6) * scale;
                const pipeLeft = p.x;
                const pipeRight = p.x + this.w * scale;
                const pipeTopY = p.y;
                const pipeBottomY = p.y + this.gap * scale;

                // Collision Logic
                // If Invincible, skip death check
                if (bird.powers.invincible === 0) {
                    if (bird.x + birdRad > pipeLeft && bird.x - birdRad < pipeRight) {
                        if (bird.y - birdRad < pipeTopY || bird.y + birdRad > pipeBottomY) {
                            bird.die();
                        }
                    }
                }

                if (p.x + (this.w * scale) < bird.x && !p.passed) {
                    score.value += 1;
                    scoreHud.innerText = score.value;
                    p.passed = true;
                    sounds.score();
                    score.high = Math.max(score.value, score.high);
                    localStorage.setItem("flappy_highscore", score.high);
                }

                if (p.x + (this.w * scale) <= 0) {
                    this.position.shift();
                    i--;
                }
            }
        },
        
        reset: function() {
            this.position = [];
        }
    }

    const score = {
        high: parseInt(localStorage.getItem("flappy_highscore")) || 0,
        value: 0
    }

    function flashScreen() {
        flashOverlay.style.opacity = 0.8;
        setTimeout(() => {
            flashOverlay.style.opacity = 0;
        }, 100);
    }

    function showGameOver() {
        finalScoreEl.innerText = score.value;
        highScoreEl.innerText = score.high;
        
        medalDisplay.innerHTML = "";
        if(score.value >= 10) {
            let medal = "ðŸ¥‰"; 
            let color = "#cd7f32";
            if(score.value >= 20) { medal = "ðŸ¥ˆ"; color = "#c0c0c0"; } 
            if(score.value >= 30) { medal = "ðŸ¥‡"; color = "#ffd700"; } 
            if(score.value >= 40) { medal = "ðŸ’Ž"; color = "#e5e4e2"; } 
            
            medalDisplay.innerHTML = medal;
            medalDisplay.style.borderColor = color;
        } else {
            medalDisplay.innerHTML = "";
            medalDisplay.style.borderColor = "transparent";
        }

        scoreHud.classList.add('hidden');
        gameOverScreen.classList.remove('hidden');
        
        // Hide bars
        barInvincible.style.display = 'none';
        barShrink.style.display = 'none';
    }

    // --- Main Loop ---

    function draw() {
        bg.draw();
        pipes.draw();
        powerUps.draw(); // Draw powerups
        ground.draw();
        bird.draw();
    }

    function update() {
        bird.update();
        pipes.update();
        powerUps.update();
    }

    function loop() {
        update();
        draw();
        frames++;
        requestAnimationFrame(loop);
    }

    highScoreEl.innerText = score.high;
    loop();

</script>
</body>
</html>
