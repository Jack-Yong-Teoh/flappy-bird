<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Bird v1.0.1</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            overflow: hidden;
            font-family: 'VT323', monospace;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #333;
            overflow: hidden;
            margin: 0 auto;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #flash-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s ease-out;
            z-index: 20;
        }

        .score-display {
            position: absolute;
            top: 10%;
            font-size: 80px;
            color: white;
            text-shadow: 4px 4px 0 #000;
            z-index: 10;
            font-family: 'VT323', monospace;
            pointer-events: none;
        }

        #start-screen, #game-over-screen {
            pointer-events: auto;
            text-align: center;
            background: rgba(0, 0, 0, 0.5); 
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(2px);
            width: 80%;
            max-width: 320px;
        }

        .score-card {
            background-color: #eec39a;
            border: 4px solid #543847;
            border-radius: 10px;
            padding: 15px;
            margin: 15px auto;
            position: relative;
            box-shadow: 6px 6px 0 rgba(0,0,0,0.4);
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-between;
        }

        .medal-container {
            width: 60px;
            height: 60px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            border: 3px solid #fff;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }

        .score-text-group { text-align: right; }
        .score-label { color: #e86101; font-size: 20px; text-transform: uppercase; letter-spacing: 1px; }
        .score-value { font-size: 30px; color: #fff; text-shadow: 2px 2px 0 #000; }

        h1 {
            color: #f4b642;
            font-size: 60px;
            margin: 0 0 10px 0;
            text-shadow: 4px 4px 0 #000, -2px -2px 0 #000;
            line-height: 0.9;
        }

        .btn {
            background: linear-gradient(to bottom, #e86101, #bf4d00);
            color: white;
            border: 2px solid white;
            padding: 12px 30px;
            font-size: 24px;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            margin-top: 10px;
            box-shadow: 0 5px 0 #8a3800, 0 10px 10px rgba(0,0,0,0.3);
            font-family: 'VT323', monospace;
            transition: all 0.1s;
        }

        .btn:active {
            transform: translateY(5px);
            box-shadow: 0 0 0 #8a3800;
        }

        .hidden { display: none !important; }

        .power-bar-container {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 15;
            pointer-events: none;
        }

        .power-bar {
            width: 150px;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            overflow: hidden;
            display: none;
            border: 2px solid white;
            box-shadow: 2px 2px 0 #000;
        }

        .power-fill {
            height: 100%;
            width: 100%;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div class="power-bar-container">
        <div id="bar-invincible" class="power-bar">
            <div class="power-fill" style="background: linear-gradient(90deg, #ffd700, #ffaa00);"></div>
        </div>
        <div id="bar-shrink" class="power-bar">
            <div class="power-fill" style="background: linear-gradient(90deg, #4287f5, #0051d4);"></div>
        </div>
    </div>

    <div id="flash-overlay"></div>
    <div class="score-display hidden" id="score-hud">0</div>

    <div id="ui-layer">
        <div id="start-screen">
            <h1>FLAPPY<br>BIRD</h1>
            <p style="color:white; font-size: 22px; text-shadow:1px 1px 0 #000;">Collect Stars & Potions!</p>
            <button class="btn" id="start-btn">Start Game</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <h1 style="font-size: 50px; margin-bottom: 10px;">GAME OVER</h1>
            
            <div class="score-card">
                <div class="medal-container" id="medal-display"></div>
                <div class="score-text-group">
                    <div class="score-label">Score</div>
                    <div class="score-value" id="final-score">0</div>
                    <div class="score-label">Best</div>
                    <div class="score-value" id="high-score">0</div>
                </div>
            </div>

            <button class="btn" id="restart-btn">Play Again</button>
        </div>
    </div>
</div>

<script>
    // --- Audio System ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    let audioInitialized = false;

    function initAudio() {
        if (!audioInitialized && audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
                audioInitialized = true;
            });
        }
    }

    const sounds = {
        jump: () => playTone(350, 'square', 0.1, -12, 0),
        score: () => playTone(1200, 'sine', 0.1, -18, 0),
        hit: () => playTone(150, 'sawtooth', 0.05, -5, 0),
        die: () => playTone(100, 'sawtooth', 0.2, -5, 0.1),
        swoosh: () => playTone(600, 'triangle', 0.1, -15, 0),
        powerup: () => playTone(600, 'sine', 0.3, -10, 0, 'slide')
    };

    function playTone(freq, type, duration, vol, delay, effect) {
        const t = audioCtx.currentTime + delay;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, t);
        
        if(effect === 'slide') {
             osc.frequency.exponentialRampToValueAtTime(freq + 600, t + 0.3);
        } else if(type === 'square') {
            osc.frequency.exponentialRampToValueAtTime(freq + 200, t + 0.1);
        }

        gain.gain.setValueAtTime(Math.pow(10, vol/20), t);
        gain.gain.exponentialRampToValueAtTime(0.001, t + duration);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        
        osc.start(t);
        osc.stop(t + duration);
    }

    // --- Game Engine ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const container = document.getElementById('game-container');
    
    // UI Elements
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const scoreHud = document.getElementById('score-hud');
    const finalScoreEl = document.getElementById('final-score');
    const highScoreEl = document.getElementById('high-score');
    const medalDisplay = document.getElementById('medal-display');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');
    const flashOverlay = document.getElementById('flash-overlay');
    const barInvincible = document.getElementById('bar-invincible');
    const barShrink = document.getElementById('bar-shrink');

    let frames = 0;
    const DEGREE = Math.PI / 180;
    
    const state = {
        current: 0,
        getReady: 0,
        game: 1,
        over: 2
    };

    let scale = 1;
    
    function resize() {
        const rect = container.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        scale = canvas.width / 320; 
        if (scale > 1.5) scale = 1.5;
    }
    
    window.addEventListener('resize', resize);
    resize();

    // --- Core Game Reset Logic ---
    function resetGameEngine() {
        state.current = state.getReady;
        pipes.reset();
        bird.reset();
        powerUps.reset();
        clouds.reset();
        
        score.value = 0;
        scoreHud.innerText = "0";
        frames = 0;
        flashOverlay.style.opacity = 0;
        
        gameOverScreen.classList.add('hidden');
        startScreen.classList.remove('hidden');
        scoreHud.classList.add('hidden');
        barInvincible.style.display = 'none';
        barShrink.style.display = 'none';
        
        sounds.swoosh();
    }

    function startGameAction() {
        initAudio(); 
        state.current = state.game;
        scoreHud.classList.remove('hidden');
        startScreen.classList.add('hidden');
        bird.flap();
        sounds.jump();
    }

    function inputAction(e) {
        if(e.type === 'keydown' && e.code !== 'Space') return;
        if(e.type === 'keydown') e.preventDefault(); 
        
        initAudio();

        switch (state.current) {
            case state.getReady:
                startGameAction();
                break;
            case state.game:
                bird.flap();
                sounds.jump();
                break;
            case state.over:
                break;
        }
    }

    startBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        startGameAction();
    });

    restartBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        resetGameEngine();
    });

    window.addEventListener('keydown', inputAction);
    canvas.addEventListener('mousedown', (e) => {
        if(state.current === state.game) inputAction(e);
    });
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); 
        if(state.current === state.game) inputAction(e);
    }, {passive: false});

    // --- Visual Objects ---

    const bg = {
        // COMPLELTY REWRITTEN FOR SMOOTHNESS
        draw: function() {
            const w = canvas.width;
            const h = canvas.height;
            const groundY = h - (ground.h * scale);

            // 1. Noon Sky (Static)
            let grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, "#4fc3f7"); 
            grad.addColorStop(1, "#2980b9");
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Calculate scroll position based on frames
            let scrollSpeed = 0.5 * scale;
            let totalScroll = (state.current == state.game) ? frames * scrollSpeed : 0;

            // 2. Cityscape Hills (Smooth Scroll using world coordinates)
            ctx.fillStyle = "#8bc34a"; 
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            // Use a fine step for smooth curves
            for(let i = 0; i <= w; i += 5 * scale) {
                let worldX = i + totalScroll * 0.5; // Hills move slower
                // Shape depends on worldX, so it doesn't morph as it moves
                let hillY = groundY - 150 * scale - Math.sin(worldX * 0.005) * 30 * scale;
                ctx.lineTo(i, hillY);
            }
            ctx.lineTo(w, groundY);
            ctx.lineTo(0, groundY);
            ctx.fill();

            // 3. Buildings (Smooth Scroll with fixed identity)
            let bStep = 40 * scale; // Wider buildings
            let bOffset = totalScroll % bStep;
            
            ctx.fillStyle = "#aed581"; 
            // Draw from off-screen left to ensure coverage
            for(let i = -bOffset - bStep; i < w; i += bStep) {
                let worldX = i + totalScroll;
                // Calculate a fixed index for this building block based on world coordinate
                let bIndex = Math.floor(worldX / bStep);

                // Use the index to create a deterministic, fixed height
                // The magic numbers generate a pseudo-random fixed pattern
                let bh = 50 * scale + (Math.abs(Math.sin(bIndex * 123.45)) * 70 * scale);
                if(bh < 30*scale) bh = 30*scale;
                let by = groundY - bh;
                
                // Draw building body with a small gap
                ctx.fillRect(i, by, bStep - 5*scale, bh);

                // Static Windows based on deterministic index
                ctx.fillStyle = "#dcedc8"; 
                let winRow = 0;
                for(let wy = by + 8*scale; wy < groundY - 8*scale; wy += 12*scale) {
                     winRow++;
                     // Fixed window pattern for this specific building index
                     if ((bIndex * 13 + winRow * 7) % 4 === 0) {
                        ctx.fillRect(i + 5*scale, wy, 6*scale, 6*scale);
                        ctx.fillRect(i + 18*scale, wy, 6*scale, 6*scale);
                     }
                }
                ctx.fillStyle = "#aed581"; // Reset color
            }
        }
    }

    const clouds = {
        items: [],
        update: function() {
            this.items.forEach(c => c.x -= 0.5 * scale);
            this.items = this.items.filter(c => c.x + c.w > -50);
            if(frames % 150 === 0) {
                this.items.push({
                    x: canvas.width,
                    y: Math.random() * (canvas.height/2),
                    w: 60 * scale + Math.random() * 40 * scale
                });
            }
        },
        draw: function() {
            ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
            this.items.forEach(c => {
                ctx.beginPath();
                ctx.arc(c.x, c.y, c.w/3, 0, Math.PI * 2);
                ctx.arc(c.x + c.w/4, c.y - c.w/4, c.w/2.5, 0, Math.PI * 2);
                ctx.arc(c.x + c.w/2, c.y, c.w/3, 0, Math.PI * 2);
                ctx.fill();
            });
        },
        reset: function() { this.items = []; }
    };

    const ground = {
        h: 90, 
        draw: function() {
            const h = this.h * scale;
            const y = canvas.height - h;
            
            ctx.fillStyle = "#ded895";
            ctx.fillRect(0, y, canvas.width, h);
            
            ctx.fillStyle = "#d0c874";
            for(let i=0; i<canvas.width; i+=10*scale) {
                if(i%3==0) ctx.fillRect(i, y + 10*scale, 4*scale, 4*scale);
                if(i%7==0) ctx.fillRect(i, y + 30*scale, 4*scale, 4*scale);
            }

            const stripeW = 20 * scale;
            let offset = 0;
            if(state.current == state.game || state.current == state.getReady) {
                offset = (frames * (2.0 * scale)) % stripeW;
            }
            
            ctx.fillStyle = "#73bf2e";
            ctx.fillRect(0, y, canvas.width, 15*scale);
            
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.lineWidth = 3 * scale;
            ctx.strokeStyle = "#558c22";
            ctx.stroke();
            
            ctx.fillStyle = "#558c22";
            for(let i = -1; i < canvas.width / stripeW + 1; i++) {
                let gx = i * stripeW - offset;
                ctx.beginPath();
                ctx.moveTo(gx, y);
                ctx.lineTo(gx + 12*scale, y);
                ctx.lineTo(gx + 4*scale, y + 15*scale);
                ctx.lineTo(gx - 8*scale, y + 15*scale);
                ctx.fill();
            }
        }
    }

    const bird = {
        animation: [0, 1, 2, 1],
        x: 50,
        y: 150,
        speed: 0,
        gravity: 0.18, 
        jump: 3.6,       
        rotation: 0,
        radius: 12,
        frame: 0,
        powers: { invincible: 0, shrink: 0 },
        
        draw: function() {
            let birdX = this.x * scale;
            let birdY = this.y;
            
            let scaleMult = this.powers.shrink > 0 ? 0.6 : 1.0;
            let size = this.radius * 2.4 * scale * scaleMult; 

            ctx.save();
            ctx.translate(birdX, birdY);

            if(this.powers.invincible > 0) {
                ctx.beginPath();
                ctx.arc(0, 0, size/1.5 + 8, 0, Math.PI*2);
                ctx.strokeStyle = `rgba(255, 215, 0, ${Math.abs(Math.sin(frames/5)) + 0.3})`;
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.fillStyle = `rgba(255, 255, 200, 0.2)`;
                ctx.fill();
            }

            ctx.rotate(this.rotation);

            let grad = ctx.createRadialGradient(-size/6, -size/6, size/10, 0, 0, size/2);
            grad.addColorStop(0, "#ffd54f");
            grad.addColorStop(1, "#f57f17");
            
            ctx.beginPath();
            ctx.arc(0, 0, size/2, 0, Math.PI*2);
            ctx.fillStyle = grad;
            ctx.fill();
            
            ctx.lineWidth = 2;
            ctx.strokeStyle = "#333";
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(size/4, -size/4, size/3.5, 0, Math.PI*2);
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(size/3, -size/4, size/10, 0, Math.PI*2);
            ctx.fillStyle = "#000";
            ctx.fill();

            ctx.beginPath();
            const wingY = (this.animation[this.frame] === 1) ? 0 : (this.animation[this.frame] === 0 ? -4 : 4);
            ctx.ellipse(-size/8, size/8 + wingY, size/2.2, size/3.5, -0.2, 0, Math.PI*2);
            ctx.fillStyle = "#fff";
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(size/2.5, size/6, size/4.5, 0, Math.PI*2);
            ctx.fillStyle = "#ff5722";
            ctx.fill();
            ctx.stroke();

            ctx.restore();
            this.updateUI();
        },
        
        updateUI: function() {
            if (this.powers.invincible > 0) {
                barInvincible.style.display = 'block';
                barInvincible.querySelector('div').style.width = (this.powers.invincible / 300 * 100) + '%';
            } else {
                barInvincible.style.display = 'none';
            }
            
            if (this.powers.shrink > 0) {
                barShrink.style.display = 'block';
                barShrink.querySelector('div').style.width = (this.powers.shrink / 480 * 100) + '%';
            } else {
                barShrink.style.display = 'none';
            }
        },
        
        flap: function() {
            let jumpForce = this.jump;
            if(this.powers.shrink > 0) jumpForce *= 0.85; 
            
            this.speed = -jumpForce * scale;
            this.rotation = -25 * DEGREE;
        },
        
        update: function() {
            if (this.powers.invincible > 0) this.powers.invincible--;
            if (this.powers.shrink > 0) this.powers.shrink--;

            const period = state.current == state.getReady ? 10 : 5;
            this.frame += frames % period == 0 ? 1 : 0;
            this.frame = this.frame % this.animation.length;

            if (state.current == state.getReady) {
                this.y = (canvas.height / 2) - 50 * scale;
                this.y += Math.cos(frames/15) * 4 * scale;
                this.x = canvas.width / 2 - (15 * scale);
                this.rotation = 0;
            } else {
                this.x = canvas.width / 3;
                this.speed += this.gravity * scale;
                this.y += this.speed;

                if(this.speed < this.jump/2 * scale) {
                    this.rotation = -25 * DEGREE;
                } else {
                    this.rotation += 2 * DEGREE;
                    this.rotation = Math.min(this.rotation, 90 * DEGREE);
                }

                if (this.y + this.radius * scale >= canvas.height - (ground.h * scale)) {
                    this.y = canvas.height - (ground.h * scale) - this.radius * scale;
                    this.die();
                }
                
                if (this.y < 0) {
                    this.y = 0;
                    this.speed = 0;
                }
            }
        },
        
        die: function() {
            if (state.current == state.game) {
                state.current = state.over;
                sounds.hit();
                setTimeout(sounds.die, 300);
                flashScreen();
                showGameOver();
            }
        },

        reset: function() {
            this.speed = 0;
            this.rotation = 0;
            this.y = 150;
            this.powers.invincible = 0;
            this.powers.shrink = 0;
        }
    }
    
    const powerUps = {
        items: [], 
        
        draw: function() {
            for(let i=0; i<this.items.length; i++) {
                let p = this.items[i];
                let px = p.x;
                let py = p.y;
                let sz = 20 * scale;
                
                ctx.save();
                ctx.translate(px + sz/2, py + sz/2);
                ctx.translate(0, Math.sin(frames/10) * 5); 
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = "white";

                if(p.type === 0) { // Star
                    ctx.beginPath();
                    for(let j=0; j<5; j++) {
                        ctx.lineTo(Math.cos((18 + j*72)*DEGREE)*sz, -Math.sin((18+j*72)*DEGREE)*sz);
                        ctx.lineTo(Math.cos((54 + j*72)*DEGREE)*sz/2, -Math.sin((54+j*72)*DEGREE)*sz/2);
                    }
                    ctx.closePath();
                    let grd = ctx.createRadialGradient(0,0,0, 0,0,sz);
                    grd.addColorStop(0, "white");
                    grd.addColorStop(1, "#ffd700");
                    ctx.fillStyle = grd;
                    ctx.fill();
                    ctx.strokeStyle = "#d4af37";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else { // Potion
                    let grd = ctx.createRadialGradient(-sz/4, -sz/4, 2, 0, 0, sz);
                    grd.addColorStop(0, "#80bfff");
                    grd.addColorStop(1, "#0066cc");
                    
                    ctx.fillStyle = grd;
                    ctx.beginPath();
                    ctx.arc(0, 0, sz/1.5, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.strokeStyle = "white";
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = "rgba(255,255,255,0.8)";
                    ctx.beginPath();
                    ctx.arc(-sz/3, -sz/3, sz/5, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();
            }
        },
        
        update: function() {
             if (state.current !== state.game) return;
             
             if(frames % 300 === 150) { 
                 if(Math.random() > 0.3) { 
                     const type = Math.random() > 0.5 ? 0 : 1;
                     const groundY = canvas.height - (ground.h * scale);
                     const y = Math.random() * (groundY - 150) + 50;
                     
                     this.items.push({
                         x: canvas.width,
                         y: y,
                         type: type,
                         active: true
                     });
                 }
             }
             
             for(let i=0; i<this.items.length; i++) {
                 let p = this.items[i];
                 p.x -= pipes.dx * scale; 
                 
                 let birdSz = bird.radius * 2 * scale;
                 let pSz = 30 * scale; 
                 if (bird.x < p.x + pSz && bird.x + birdSz > p.x &&
                     bird.y < p.y + pSz && bird.y + birdSz > p.y) {
                     
                     sounds.powerup();
                     if(p.type === 0) {
                         bird.powers.invincible = 300; 
                     } else {
                         bird.powers.shrink = 480; 
                     }
                     
                     this.items.splice(i, 1);
                     i--;
                     continue;
                 }
                 
                 if(p.x < -50) {
                     this.items.splice(i, 1);
                     i--;
                 }
             }
        },
        
        reset: function() {
            this.items = [];
        }
    }

    const pipes = {
        position: [],
        w: 52, 
        dx: 2.0,        
        gap: 125,        
        
        draw: function() {
            for (let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                let topY = p.y;
                let bottomY = p.y + this.gap * scale;
                let pX = p.x;
                let pW = this.w * scale;
                
                // Green Pipe Gradient
                let pipeGrad = ctx.createLinearGradient(pX, 0, pX + pW, 0);
                pipeGrad.addColorStop(0, "#2e7d32");   // Dark edge
                pipeGrad.addColorStop(0.2, "#43a047"); // Main green
                pipeGrad.addColorStop(0.5, "#81c784"); // Highlight
                pipeGrad.addColorStop(0.8, "#43a047"); // Main green
                pipeGrad.addColorStop(1, "#1b5e20");   // Shadow edge
                
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#000";

                // --- TOP PIPE ---
                let topCapH = 24 * scale;
                // Body
                ctx.fillStyle = pipeGrad;
                ctx.fillRect(pX, 0, pW, topY - topCapH);
                ctx.strokeRect(pX, -2, pW, topY - topCapH + 2);
                // Cap
                let topCapY = topY - topCapH;
                ctx.fillRect(pX - 2*scale, topCapY, pW + 4*scale, topCapH);
                ctx.strokeRect(pX - 2*scale, topCapY, pW + 4*scale, topCapH);


                // --- BOTTOM PIPE ---
                let botCapH = 24 * scale;
                // Cap
                ctx.fillStyle = pipeGrad;
                ctx.fillRect(pX - 2*scale, bottomY, pW + 4*scale, botCapH);
                ctx.strokeRect(pX - 2*scale, bottomY, pW + 4*scale, botCapH);
                // Body
                let bodyStart = bottomY + botCapH;
                let bodyH = canvas.height - bodyStart - (ground.h * scale);
                ctx.fillRect(pX, bodyStart, pW, bodyH);
                ctx.strokeRect(pX, bodyStart, pW, bodyH + 2);
            }
        },
        
        update: function() {
            if (state.current !== state.game) return;

            if (frames % 110 == 0) {
                const groundY = canvas.height - (ground.h * scale);
                const gapSize = this.gap * scale;
                
                const minPipe = 40 * scale;
                const maxPipe = groundY - minPipe - gapSize;

                const posY = Math.random() * (maxPipe - minPipe) + minPipe;

                this.position.push({
                    x: canvas.width,
                    y: posY,
                    passed: false
                });
            }

            for (let i = 0; i < this.position.length; i++) {
                let p = this.position[i];
                p.x -= this.dx * scale;

                let effectiveRadius = bird.radius;
                if (bird.powers.shrink > 0) effectiveRadius *= 0.6; 
                
                const birdRad = (effectiveRadius - 4) * scale;
                const pipeLeft = p.x;
                const pipeRight = p.x + this.w * scale;
                const pipeTopY = p.y;
                const pipeBottomY = p.y + this.gap * scale;

                if (bird.powers.invincible === 0) {
                    if (bird.x + birdRad > pipeLeft && bird.x - birdRad < pipeRight) {
                        if (bird.y - birdRad < pipeTopY || bird.y + birdRad > pipeBottomY) {
                            bird.die();
                        }
                    }
                }

                if (p.x + (this.w * scale) < bird.x && !p.passed) {
                    score.value += 1;
                    scoreHud.innerText = score.value;
                    p.passed = true;
                    sounds.score();
                    score.high = Math.max(score.value, score.high);
                    localStorage.setItem("flappy_highscore", score.high);
                }

                if (p.x + (this.w * scale) <= 0) {
                    this.position.shift();
                    i--;
                }
            }
        },
        
        reset: function() {
            this.position = [];
        }
    }

    const score = {
        high: parseInt(localStorage.getItem("flappy_highscore")) || 0,
        value: 0
    }

    function flashScreen() {
        flashOverlay.style.opacity = 0.8;
        setTimeout(() => {
            flashOverlay.style.opacity = 0;
        }, 100);
    }

    function showGameOver() {
        finalScoreEl.innerText = score.value;
        highScoreEl.innerText = score.high;
        
        medalDisplay.innerHTML = "";
        medalDisplay.style.background = "rgba(0,0,0,0.1)";
        
        if(score.value >= 10) {
            let medal = "ðŸ¥‰"; 
            let color = "#cd7f32";
            if(score.value >= 20) { medal = "ðŸ¥ˆ"; color = "#c0c0c0"; } 
            if(score.value >= 30) { medal = "ðŸ¥‡"; color = "#ffd700"; } 
            if(score.value >= 40) { medal = "ðŸ’Ž"; color = "#b9f2ff"; } 
            
            medalDisplay.innerHTML = medal;
            medalDisplay.style.borderColor = color;
            medalDisplay.style.background = "rgba(255,255,255,0.3)";
        } else {
            medalDisplay.innerHTML = "";
            medalDisplay.style.borderColor = "transparent";
        }

        scoreHud.classList.add('hidden');
        gameOverScreen.classList.remove('hidden');
        
        barInvincible.style.display = 'none';
        barShrink.style.display = 'none';
    }

    // --- Main Loop ---

    function draw() {
        bg.draw();
        clouds.draw();
        pipes.draw();
        powerUps.draw(); 
        ground.draw();
        bird.draw();
    }

    function update() {
        bird.update();
        pipes.update();
        powerUps.update();
        clouds.update();
    }

    function loop() {
        update();
        draw();
        frames++;
        requestAnimationFrame(loop);
    }

    highScoreEl.innerText = score.high;
    loop();

</script>
</body>
</html>
